
# RB101-easy_1-question_1

2011
2014

What would you expect the code below to print out?

```ruby
numbers = [1, 2, 2, 3]
numbers.uniq

puts numbers
```

The non-destructive `uniq` method is called on `numbers` that references the array object `[1, 2, 2, 3]`. `uniq` checks for elements that occur more than once and removes any duplicates while keeping at least one of those values, and then returns a new array with only one occurrence of each value.

`puts numbers` outputs the values of the original array object because `uniq` does not modify the original object but rather returns a new object.

```
Output:
1
2
2
3
```

# RB101-easy_2-question_1

2016
2018

```ruby
# In this hash of people and their age,

ages = { "Herman" => 32, "Lily" => 30, "Grandpa" => 402, "Eddie" => 10 }

# see if "Spot" is present.

# Bonus: What are two other hash methods that would work just as well for this solution?
```

```ruby
ages = { "Herman" => 32, "Lily" => 30, "Grandpa" => 402, "Eddie" => 10 }

p ages.include?("Spot")
p ages.has_key?("Spot")
p ages.key?("Spot")
```

# RB101-medium_1-question_1

2021
2023

```ruby
# Let's do some "ASCII Art" (a stone-age form of nerd artwork from back in the days before computers had video screens).

# For this practice problem, write a one-line program that creates the following output 10 times, with the subsequent line indented 1 space to the right:

# The Flintstones Rock!
#  The Flintstones Rock!
#   The Flintstones Rock!
```

```ruby
10.times { |i| puts (" " * i) + "The Flintstones Rock!"}
```

# RB101-medium_2-question_1

2026
2031

```ruby
# Every object in Ruby has access to a method called object_id, which returns a numerical value that uniquely identifies the object. This method can be used to determine whether two variables are pointing to the same object.

# Take a look at the following code and predict the output:

a = "forty two"
b = "forty two"
c = a

puts a.object_id
puts b.object_id
puts c.object_id
```

The variable `a` is initialised with a reference to the string object `"forty two"`. `b` is initialised with a reference to another string object `"forty two"`. Even though the string object's contents have the same values, they are actually two distinct objects located in different address spaces in memory. This can be confirmed by calling `object_id` on these variables, which will return two unique object ids. Therefore `a` and `b` do not point to the same string object.

In the assignment of one variable to another, `c` receives a copy of the reference stored in the variable `a`. All three objects appear have the same string value, but their object ids are indeed different. `a` and `c` contain references to the same string object, while `b` references a completely different object with the same string value.

```
# Diagram

a --> "forty two"
b --> "forty two"

# After assignment of c = a
a --> "forty two" <-- c
b --> "forty two"

# Output
puts a.object_id # object id 1000001 (this will be a unique id on your computer)
puts b.object_id # object id 1000002
puts c.object_id # object id 1000001
```

# RB101-hard_1-question_1

2036
2039

```ruby
# What do you expect to happen when the greeting variable is referenced in the last line of the code below?

if 1 + 2
  greeting = "hello world"
end

puts greeting
```

The conditional `if` statement is evaluated: since `if 1 + 2` evaluates as truthy, the `if` branch is executed, which executes the initialisation of the variable `greeting` with a reference to the string object `"hello world"`.

Conditionals do not create their own scope; variables initialised within an `if` statement can be accessed throughout the scope it was defined in—in this case, `greeting` is available throughout the main scope.

`puts greeting` will output `"hello world"` since it has access to the `greeting` variable in the main scope.

# ruby_basics-loops_1-Runaway Loop

The code below is an example of an infinite loop. The name describes exactly what it does: loop infinitely. This loop isn't useful in a real program, though. Modify the code so the loop stops after the first iteration.

```ruby
loop do
  puts 'Just keep printing...'
end
```

```ruby
# Refactored

loop do
  puts 'Just keep printing...'
  break
end
```

The `loop` method allows for iteration until execution reaches a `break` keyword (typically after some condition is met), otherwise the program can get stuck in an infinite loop.

In this code, simply adding `break` after the `puts` method call will break out of the loop after the first iteration.

# ruby_basics-return-Breakfast, Lunch, or Dinner? (Part 1)

What will the following code print? Why? Don't run it until you've attempted to answer.

```ruby
def meal
  return 'Breakfast'
end

puts meal
```

When `puts meal` is called, `meal` is evaluated as the method definition with the name `meal`.  This means that the `meal` method is called and evaluated, and its return value is then immediately passed as an argument to the `puts` method call, which prints that return value.

`puts meal` could be written as `puts(meal())`: this syntax explicitly shows that `meal` is a method invocation, not a variable.

```ruby
def meal
  return 'Breakfast'
end

# Puts call could be written with optional parentheses to make it clearer that puts prints the return value of the meal method call
puts(meal())

# Return value of `meal` method => 'Breakfast'
# puts('Breakfast') --> output: Breakfast
```

```
Output:

Breakfast
```

# ruby_basics-variable_scope-What's My Value? (Part 1)

What will the following code print and why? Don't run it until you have tried to answer.

```ruby
a = 7

def my_value(b)
  b += 10
end

my_value(a)
puts a
```

The variable `a` is initialised with a reference to the integer `7`. `my_value(a)` is a method invocation that's passed `a` as an argument. Inside the method definition, the parameter `b` is bound to the same integer `7` that `a` references.

`b += 10` is evaluated: `+=` is a reassignment operator, which creates a new object (rather than modifying the original object) and changes what the variable references (effectively disconnecting the reference to the original object from the local variable that's being reassigned). In Ruby, integers are immutable objects, which means that they cannot be changed after they are created; therefore new integer objects would be created as a result of assignment operations in any case.

`b` is therefore reassigned to the value of `b` incremented by `10`, resulting in `17`, which is then assigned back to `b`. This evaluated result is also the same as the return value of the method which is passed back to the calling code, although this code does not use this return value.

`puts a` outputs the original integer object that the outer variable `a` references—`7`—which was not modified by the `my_value` method invocation.

This code demonstrates Ruby's pass by reference value behaviour, especially how it can appear that copies of values are passed to methods as arguments, since the operations inside the method do not have an effect on the original object outside the method. That being said, integers are immutable objects in Ruby, so they cannot be mutated by operations anyway.