**Question 1: Variable Scope (Basic)**

What will the following code output? Explain why.

```ruby
a = "hello"

def my_method
  puts a
end

my_method
```

In the main scope, the variable `a` is initialised with a reference to the string object `"hello"`.

`my_method` is called, and inside the method definition, `puts a` is evaluated: a `NameError` message is thrown because there is no variable (or method) called `a` available inside the method. The code is terminated at this error message; there is no output.

An error is raised due to scoping rules of a method definition. Method definitions create a self-contained scope where variables initialised inside the method cannot be accessed by the outer scope, and variables initialised in the outer code cannot be directly accessed or modified unless they are passed as arguments during a method invocation. The variable `a` was initialised in the outer scope, therefore `my_method` does not have access to this variable.

**Question 2: Variable Mutation (Intermediate)**

What will the following code output? Explain in detail.

```ruby
array = [1, 2, 3, 4]
new_array = array.map do |num|
  num * 2
end

array.each do |num|
  puts num
end

puts "---"

new_array.each do |num|
  puts num
end
```

The variable `array` is initialised with a reference to the array object `[1, 2, 3, 4]`, and `new_array` is initialised with a reference to the return value of `map` called on `array`. The `map` method call must be evaluated to determine the evaluation of the assignment operation of `new_array`.

The non-destructive `map` method iterates over the calling collection and executes the block code for each iteration, and returns a new array containing the return values from the block, effectively transforming the values of the original elements. Since `map` is a non-mutating method, the original array object that it's called on, `array`, remains unchanged.

Inside the `map` method invocation block, the parameter `num` is assigned the value of the current element and executes the block code: `num * 2` is evaluated, which multiples the value of `num` by `2`—the evaluated result is added to the return array on each iteration, until all iterations are completed. For this code, `map` returns `[2, 4, 6, 8]`, which is passed back to the calling code, and the return array is assigned to `new_array`.

When `each` is called on `array`, it iterates over the array object and executes the block code, but unlike `map`, it returns the original calling object. The block code executes `puts num` for each iteration, outputting the value of each element in `array` separated by newlines.

`puts "---"` outputs the string `"---"` in a newline.

Finally, the `each` method is called on `new_array`, which outputs each element in the array per iteration.

```
# Output
1
2
3
4
---
2
4
6
8
```

**Question 3: Method Return Values (Intermediate)**

What will be the return value of the `select` method in the following code? Explain your answer with reference to how the `select` method works.

```ruby
['ant', 'bat', 'caterpillar'].select do |str|
  str.length < 4
end
```

The non-destructive `select` method iterates over a collection of data and executes the block code, and ultimately returns a new array containing elements from the original array based on the truthiness of the block's return values on each iteration. If the block's return value is evaluated as truthy, the element is added to the new array, otherwise if it's falsy, nothing happens to the new array on that iteration (the new array is intialised as an empty array `[]` at the beginning of the method's execution).

In this code, `select` is called on an array containing string objects of varying lengths. The block parameter `str` is assigned to the current element, and then the conditional expression `str.length < 4` is evaluated. `length` will return the number of characters in the string as an integer, and then the comparison `<` operator can be evaluated as either boolean `true` or `false`. This boolean value is the same as the block's return value since it is also the last evaluated expression in the code. `select` then checks for the values truthiness: if the conditional expression's evaluated result is `true`, a truthy value, the current element is selected and added to the return array; otherwise if the evaluated result is the falsy value `false`, nothing happens to the return array.

```
# Breakdown

# 1st iteration
str => 'ant'
str.length => 3
str.length < 4 => true
block's return value => true
truthiness of block's return value --> truthy
new return array => ['ant']

# 2nd iteration
str => 'bat'
str.length => 3
str.length < 4 => true
block's return value => true
truthiness of block's return value --> truthy
new return array => ['ant', 'bat']

# 3rd iteration
str => 'caterpillar'
str.length => 11
str.length < 4 => false
block's return value => false
truthiness of block's return value --> falsy
new return array => ['ant', 'bat']

# select method's return value
=> ['ant', 'bat']
```

**Question 4: Truthiness and Flow Control (Advanced)**

What will the following code output? Explain in detail, focusing on how Ruby evaluates truthiness and the behavior of the `if` statements.

```ruby
a = false
b = nil
c = "hello"
d = 0

if a
  puts "a is truthy"
elsif b
  puts "b is truthy"
elsif c
  puts "c is truthy"
elsif d
  puts "d is truthy"
else
  puts "none are truthy"
end
```

Every expression in Ruby is considered truthy except for the two falsy values `false` and `nil`. Truthiness refers to what values are considered true (or evaluates to true, i.e. is "truthy") or considered false (or evaluates to false, i.e. is "falsy"). When an expression 'considered true', it does not necessarily evaluate to the boolean object `true`, and the same applies values that are 'considered to be false' compared to the boolean `false`.

The boolean objects `true` and `false` have the sole purpose of only conveying `true` and `false`, and in Ruby, these boolean values are not used directly in conditional contexts to determine conditional flow. Instead Ruby relies on truthiness of conditional expressions: it does not specifically check for whether the expression evaluates as `true` but rather if the expression does not evaluate to either of the falsy values `false` or `nil`. In other words, does the expression evaluate as truthy or falsy?

In this code, variables `a` and `b` contain references to the two falsy values `false` and `nil`, respectively. This means that in conditional contexts, they will be evaluated as falsy. The other two variables `c` and `d` contain references to the string object `"hello"` and the integer `0`. Since they are neither `false` or `nil`—that is, they are not falsy values—they are actually considered truthy. Note that even if `c` referenced an empty string `""` it would still be truthy because empty strings, along with empty arrays and hashes, are considered truthy in Ruby. The same applies to the integer `0`. (These 'empty' objects may be considered falsy in other languages!)

When the `if` statement at the end of the code is evaluated, it is evaluated based on the truthiness of the `if` statement: if the evaluated expression is truthy, that specific branch is executed, and if it's falsy, execution runs through the subsequent `elsif` statements until one evaluates as true (or is truthy).

```
# Breakdown

if a    # a => false --> falsy --> execution continues at next elsif statement
  puts "a is truthy"
elsif b              # b => nil --> falsy --> next elsif statement
  puts "b is truthy"
elsif c              # c => "hello" --> truthy --> branch is executed
  puts "c is truthy" # outputs "c is truthy"
elsif d
  puts "d is truthy"
else
  puts "none are truthy"
end

# Output
c is truthy
```