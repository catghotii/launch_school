
1.  ​**Basic**​: What will the following code output and why? Explain step by step.  
   
```ruby
a = "Hello"
b = a
a << " World"
puts a
puts b 
```

The variable `a` is initialised with a reference to the string object `"Hello"`. In the assignment from one variable to another, `b` receives a copy of the reference stored in `a`, with the result that both variables contain references to the same string object `"Hello"`.

On line 3, the destructive shovel operator `<<` mutates the string object referenced by `a`, concatenating its argument `" World"` with the existing string, resulting in the string `"Hello World"`. This operation modifies the object in place rather than creating a new string. This mutation can be seen through any of its references, including the variable `b`. 

`puts a` and `puts b` will output the same string.

```
# Diagram

# Original state
a --> "Hello" <-- b

# After << (mutating)
a --> "Hello World" <-- b

# Output
Hello World
Hello World
```

2.  ​**Intermediate**​: What will the following code output and why? Explain the concept being demonstrated.

```ruby
def change_name(name)
  name = "Bob"
end

name = "Jim"
change_name(name)
puts name 
```

The variable `name` is initlaised with a reference to the string object `"Jim"`. The `change_name(name)` method call is executed: inside the method definition, the parameter `name` is bound to the same string object that the outer variable `name` references—effectively, the method receives a reference to the string object. Both the outer variable `name` and the local variable to the method `name` contain references to the same string object `"Jim"`. 

The method body is evaluated: `name = "Bob"` is a reassignment operation, which creates a new string (rather than modifying the original object) `"Bob"`, and changes what the inner local variable `name` references, disconnecting it from the reference to the original string object. The reassignment, which is a non-mutating operation, has no effect on the original object or its references; the outer `name` still references the original string object `"Jim"`. The new string `"Bob"` is assigned back to the local variable `name`.

The method's return value is the same value as the last evaluated expression in the method body, `"Bob"`, which is passed back to the calling code (although this value is not used).

`puts name` will output the value of the outer variable `name`, which still points to the original object `"Jim"`.

```
# Diagram

# Original state
name (outer scope) --> "Jim"

# During change_name method call
name (outer scope) --> "Jim" <-- name (inner scope)

# After reassignment
name (outer scope) --> "Jim"
name (inner scope) --> "Bob"

# After method call execution is completed
# name (outer scope) --> "Jim"

# Output
Jim
```

This code demonstrates:
- Variable scope of a method definition, where a self-contained scope is created.
	- Variables initialised inside the method definition cannot be accessed by the outer code: this is why `puts name` outputs the string object referenced by the outer variable `name`—the outer scope only has access to variables defined in its own scope and not the method definition's scope.
	- Moreover, variables initialised in the outer code cannot be directly accessed or modified from within the method unless they are passed as arguments and mutating operations are performed on those corresponding objects.
- Ruby's pass by reference value behaviour: the method receives a reference to the object and what happens to the original object depends on whether the operations performed inside the method are destructive or non-destructive. In this code, the reassignment operation in the method demonstrates how Ruby appears to exhibit pass by value behaviour where methods receive copies of values of objects, which means operations performed by the method have no effect on the original object.
- Mutation vs reassignment: mutating operations modify the original object in place (and any changes can be examined through its references outside the method), while reassignments create new string objects and change what a variable references.

3.  ​**Basic**​: What are the return values of the following expressions? Explain your answers.  
   
```ruby
"hello".include?("lo")
[1, 2, 3].include?(1)
{a: 1, b: 2}.include?(:a)
{a: 1, b: 2}.include?(1)
```

```
Return values:
=> true
=> true
=> true
=> false
```

The `include?` method is a predicate method that returns either boolean object `true` or `false` when it is called on an object. When `include?` is passed an argument, it checks for whether the value of the argument is included in that object's actual values, depending on the type of object of the caller.

For strings, it checks for whether the argument's value is included in the contents of the string object and returns `true` if that value is included.

For arrays, it checks for whether the argument's value is an element in the array and returns `true` if that value is included..

For hashes, it checks for whether the argument's value is a key in the hash and returns `true` if that value is included. It does not check for the value of the key-value pair in a hash, which is why the last expression evaluates to `false`. (Instead another method like `has_value?` could be used). 

4.  ​**Intermediate**​: What will be output by the code below and why?  
   
```ruby
arr = [1, 2, 3, 4, 5]
new_arr = arr.select do |num|
  puts num if num.odd?
end
p new_arr
```

The variable `arr` is initialised with a reference to the array object `[1, 2, 3, 4, 5]`, and `new_arr` is initialised with a reference to the `select` method called on `arr`. The `select` method call is first evaluated and its return value is assigned to `new_arr`.

The non-destructive `select` method iterates over a collection and executes the code in the block for each iteration, and returns a new array containing the elements based on the truthiness of the return values from the block. If the block's return value is truthy, the element for that iteration is added to the return array, otherwise if it's falsy, nothing happens to the return array (which is initially created as an empty array `[]`).

In this block, the parameter `num` is assigned the value of the current element, and the block code is executed. The conditional if modifier is evaluated: if the if statement `if num.odd?` evaluates as true, `puts num` is executed, which outputs the value of `num` and also returns `nil` (since `puts` returns `nil`). If `if num.odd?` evaluates as false, `nil` is returned since there is no `else` branch to be executed.

This return value, `nil` for both possible evaluated outcomes, is also the same as the block's return value since it is the last evaluated expression in the block. `select` then checks the block's return value for truthiness: `nil` evaluates as falsy, so nothing happens to the return array on each iteration. Ultimately, `select` returns the empty array `[]`, which is passed back to the calling code, and `new_arr` now references `[]`, which can be examined when `p new_arr` is called, which outputs the empty array.

```
Output:
1
3
5
[]

# Breakdown of select

# For the 1st, 3rd, 5th iterations
num => 1 or 3 or 5
if num.odd? => true
puts num --> outputs 1 / 3 / 5, => nil
block's return value => nil
truthiness of block's return value => falsy
new return array => []

# For the 2nd, 4th iterations
num => 2 or 4
if num.odd? => false
block's return value => nil
truthiness of block's return value => falsy
new return array => []
```
    

5.  ​**Advanced**​: What will the following code output and why? Be specific about how the method works.  
   
```ruby
def fix(value)
  value.upcase!
  value.concat('!')
  value
end

s = 'hello'
t = fix(s)

puts s
puts t 
```

In the outer scope, the variable `s` is initialised with a reference to the string object `"hello"`, and `t` is initialised with a reference to the return value of `fix(s)`, which is first evaluated to determine the return value. The `fix` method is passed an argument `s`.

Inside the method definition, the parameter `value` is bound to the same string object `"hello"` that `s` references—the method receives a reference to the object. The method body is executed: the destructive `upcase!` method is called on the local variable `value`, modifying the original object in place (rather than creating a new object) by changing lowercase letters to uppercase letters, resulting in `"HELLO"`. This mutation can be seen through any of the original object's references, including the outer variable `s`. Then another mutating operation `concat` is called on `value`, again mutating the original object by concatenating its argument with the calling object, resulting in `"HELLO!"` (`s` points to this same modified object).

The last line in the method body, `value`, evaluates to `"HELLO!"`, which is also the method's return value as it is the last evaluated expression in the method. This return value is passed back to the calling code—`"HELLO!"` is assigned to the outer variable `t`.

`puts s` and `puts t` outputs the value of the same string object that has been mutated by the method call: `"HELLO!"`

```
# Output

HELLO!
HELLO!

# Diagram

# Original state
s --> "hello"

# Beginning of method invocation
s --> "hello" <-- value

# After upcase!
s --> "HELLO" <-- value

# After concat
s --> "HELLO!" <-- value

# After execution of method
s --> "HELLO!" <-- t
```

This code demonstrates some key concepts:

- Variable scope of method definitions: method definitions create a self-contained scope, which means variables initialised within the method definition cannot be accessed by the outer scope, and variables initialised in the outer scope cannot be directly accessed or modified unless they are passed as arguments during a method call and mutating operations are performed on those corresponding objects.
- Ruby's pass by reference value behaviour: the method receives a reference to the object and what happens to the original object depends on whether the operations performed inside the method are mutating or non-mutating.
- Mutating vs non-mutating operations: mutating operations modify the original object in place, and these changes can be examined through any of its references, including variables in the outer code. Non-mutating operations create new objects and change what a variable references.

6.  ​**Intermediate**​: What is the difference between the following two code snippets? What will each output and why?  
 
```ruby
# Snippet 1
numbers = [1, 2, 3, 4]
numbers.each do |number|
  p number
  numbers.shift(1)
end

# Snippet 2
numbers = [1, 2, 3, 4]
numbers.each do |number|
  p number
  numbers.pop(1)
end 
```

The `each` method allows for iterating over a collection of elements and executing operations in the block code for each iteration, and returns the original calling collection.

It's important to note that when mutating operations are performed within iteration methods and on the collection that's being iterated over, it can cause unexpected behaviours and results, depending on the user's Ruby version and how their Ruby implements built-in methods, producing unintended or inconsistent output or return values. This is why it is advised to avoid using mutating methods on the collection that's being iterated over at the same time.

The difference between the two code snippets is the specific mutating operation that is executed in the block code. 

For snippet #1, the `shift` method removes and returns the number of leading elements specified by its argument (it only removes the first element if no argument is supplied). For snippet #2, the `pop` method removes and returns the number of trailing elements specified by its argument (it only removes the last element if no argument is supplied).

```
# Breakdown

# Snippet 1 - shift method

# 1st iteration, element at index 0
numbers => [1, 2, 3, 4]
number --> element at index 0 => 1
p number --> outputs 1
numbers.shift(1) => 1
numbers => [2, 3, 4]

# 2nd iteration, element at index 1
numbers => [2, 3, 4]
number --> element at index 1 => 3
p number --> outputs 3
numbers.shift(1) => 2
numbers => [3, 4]

# each method terminates
numbers => [3, 4] <-- there are no more elements to iterate over
each method return value => [1, 2, 3, 4] <-- original calling object

# Output
1
3

# Snippet 2 - pop method

# 1st iteration, element at index 0
numbers => [1, 2, 3, 4]
number --> element at index 0 => 1
p number --> outputs 1
numbers.pop(1) => 4
numbers => [1, 2, 3]

# 2nd iteration, element at index 1
numbers => [1, 2, 3]
number --> element at index 1 => 2
p number --> outputs 2
numbers.pop(1) => 3
numbers => [1, 2]

# each method terminates
numbers => [1, 2] <-- there are no more elements to iterate over
each method return value => [1, 2, 3, 4] <-- original calling object

# Output
1
2
```

```ruby
# Comments added

# Snippet 1
numbers = [1, 2, 3, 4]
numbers.each do |number|
  p number
  numbers.shift(1) # removes the only one of the leading elements i.e. first element
end

# Snippet 2
numbers = [1, 2, 3, 4]
numbers.each do |number|
  p number
  numbers.pop(1) # removes only 1 of the trailing elements i.e. last element only
end 
```

7.  ​**Advanced**​: What will the following code output and why? Explain the concept of variable shadowing and how it applies here.  

```ruby
a = 5

3.times do |a|
  puts a
end

puts a 
```

The variable scope of a block maintains that variables initialised within a block cannot be accessed by the outer code, and variables initialised in the outer scope can be accessed and modified from within the block.

In this code, in the outer scope, the variable `a` is initialised with a reference to the integer `5`. The `times` method is called on `3` and passed a block, which executes the block code for three iterations.

Inside the block, there's a parameter `a` that has the same name as the outer variable `a`. When a block parameter has the same name as an outer variable, variable shadowing occurs, which prevents the block from accessing the variable in the outer code of the same name. (Notably, variable shadowing only occurs for block parameters that have the same name, not local variables initialised within the block that may share a name with an outer variable.)

When `puts a` is evaluated, the only variable with the name `a` available to the block is the parameter variable `a`, not the outer variable `a`. For the `times` method, the block parameter refers to the index number of that iteration. For example, on the first iteration, parameter is assigned to the value of `0`, referring to the index number of the iteration, so `puts a` outputs `0`, while the subsequent iterations will output `1` and `2`, respectively. (The `times` method returns the integer object it is called on, `3`, although this value is not used in this code.)

After execution of the `times` method, back in the outer code, `puts a` outputs the value of the outer variable `a`, since this variable is the only variable with the name `a` visible to the outer scope. `puts a` outputs `5`.

```
# Output
0
1
2
5

# Breakdown of times loop

# 1st iteration, index 0
a => 0
puts a --> outputs 0

# 2nd iteration, index 1
a => 1
puts a --> outputs 1

# 3rd iteration, index 2
a => 2
puts a --> outputs 2
```

8.  ​**Basic**​: What is the return value of each of these methods? Explain why.  
 
```ruby
[1, 2, 3].map { |num| num * 2 }
[1, 2, 3].select { |num| num > 1 }
[1, 2, 3].reject { |num| num > 1 }
[1, 2, 3].any? { |num| num > 2 }
[1, 2, 3].all? { |num| num > 0 }
```

Return values:

```
[1, 2, 3].map { |num| num * 2 }    => [2, 4, 6]
[1, 2, 3].select { |num| num > 1 } => [2, 3]
[1, 2, 3].reject { |num| num > 1 } => [1]
[1, 2, 3].any? { |num| num > 2 }   => true
[1, 2, 3].all? { |num| num > 0 }   => true
```

- `map` iterates over a collection and executes the block code, and returns a new array of  the transformed values of the original elements. The return array contains the return values of the expression executed in the block.

```
# Breakdown

# map - transforms elements based on return values from block, returns new array of transformed elements
[1, 2, 3].map { |num| num * 2 }

# 1st iteration
num => 1
num * 2 => 2
return array => [2]

# 2nd iteration
num => 2
num * 2 => 4
return array => [2, 4]

# 3rd iteration
num => 3
num * 2 => 6
return array => [2, 4. 6]

# new return array
=> [2, 4, 6]
```

- `select` iterates over a collection and executes the block code, and returns a new array of elements based on the truthiness of the block's return values. If the block's return value is truthy, the element is selected and added to the return array, otherwise if it's falsy, nothing happens to the return array on that iteration (the return array is initialised as an empty array `[]`)

```
# select - returns new array based on truthiness of block's return values
[1, 2, 3].select { |num| num > 1 }

# 1st iteration
num => 1
num > 1 => false
block's return value => false
truthiness of block's return value => falsy
return array => []

# 2nd iteration
num => 2
num > 1 => true
block's return value => true
truthiness of block's return value => truthy
return array => [2]

# 3rd iteration
num => 3
num > 1 => true
block's return value => true
truthiness of block's return value => truthy
return array => [2, 3]

# new return array
=> [2, 3]
```

- `reject` iterates over a collection and executes the block code, and returns a new array of elements based on whether the return values from the block are falsy values (`false` or `nil`).

```
# reject - returns new array based on whether block's return value is falsy
[1, 2, 3].reject { |num| num > 1 }

# 1st iteration
num => 1
num > 1 => false
block's return value => false
truthiness of block's return value => falsy
return array => [1]

# 2nd iteration
num => 2
num > 1 => true
block's return value => true
truthiness of block's return value => truthy
return array => [1]

# 3rd iteration
num => 3
num > 1 => true
block's return value => true
truthiness of block's return value => truthy
return array => [1]

# new return array
=> [1]
```

- `any?` is a predicate method which returns either boolean `true` or `false` based on whether there is at least one occurrence of a truthy block return value.

```
# any? - returns boolean true or false if at least one occurrence of truthy return value from the block
[1, 2, 3].any? { |num| num > 2 }

# 1st iteration
num => 1
num > 1 => false
block's return value => false
truthiness of block's return value => falsy
execution continues at next iteration

# 2nd iteration
num => 2
num > 1 => true
block's return value => true
truthiness of block's return value => truthy
execution terminates early due to short circuiting since the value can be guaranteed

# any? => true
```

-  `all?` is a predicate method which returns either boolean `true` or `false` based on whether all occurrences of the block return values are all truthy values.

```
# all? - returns boolean true or false if all occurrences of truthy return values from the block
[1, 2, 3].all? { |num| num > 0 }

# 1st iteration
num => 1
num > 1 => false
block's return value => false
truthiness of block's return value => falsy
execution terminates early due to short circuiting since the value can be guaranteed

# any? => false
```
    

9.  ​**Intermediate**​: What will the following code output and why?  
   
```ruby
def greetings(str)
  puts str
  puts "Goodbye"
end

word = "Hello"

greetings(word)  
```

The variable `word` is initialised with a reference to the string object `"Hello"`. The `greetings(word)` method call is evaluated and passed `word` as an argument. Inside the method definition, the parameter `str` receives a reference to the same string object that `word` references, `"Hello"`.

`puts str` outputs `"Hello"`, and `puts "Goodbye"` outputs `"Goodbye"`. The method's return value is the same value as the evaluated result of the last expression in the method: `puts "Goodbye"` returns `nil` because `puts` returns `nil`. This return value is passed back to the calling code, but it is unused in this code.

```
# Output
Hello
Goodbye
```

10. ​**Advanced**​: Consider the following code:  
   
```ruby
def fix_array(arr)
  arr.each_with_index do |element, index|
    arr[index] = element.upcase if element.start_with?('c')
  end
end

animals = ['cat', 'dog', 'cow', 'chicken', 'fish']
fix_array(animals)

p animals
```
 
   What will be the output of the code? Explain how the method changes the original array and why this behavior occurs.

The variable `animals` is initialised with a reference to the array object `['cat', 'dog', 'cow', 'chicken', 'fish']`. The `fix_array` method is called and passed `animals` as an argument.

Inside the method definition, the parameter `arr` is bound to the same array object that `animals` references. The `each_with_index` method is called on `arr`, which iterates over the array and executes the block code for each iteration, and ultimately returns the original calling object.

Inside the block, the two parameters are assigned to the value of the current element and its index position, respectively. The `if` modifier is then evaluated: if `if element.start_with?('c')` evaluates as true, then the destructive operation `arr[index] = element.upcase` is executed; if it evaluates as false, execution continues from the next iteration, until all iterations are completed.

The `Array#[]=` setter method is a destructive operation that replaces the value of the original array at the given index number specified in its argument with the value on the left of `=`. This is because array objects in Ruby are mutable objects, which means that they can be modified in place. Even though `element.upcase` is a non-destructive operation that returns a new value, this return value is assigned back to the setter method, which mutates the original array object. The mutation to the original array object can be seen through any of its references, including the outer variable `animals`, which continues to point to the same object that's being modified during the method invocation.

Once the `each_with_index` method completes its execution, it returns the original collection—notably, the original collection has been mutated, so it actually returns the original collection in a modified state compared to the array's state at the beginning of the method call. The method's return value is the same as the last evaluated expression, which is passed back to the calling code (although the return value is not used in this code).

`p animals` outputs the modified array object, `["CAT", "dog", "COW", "CHICKEN", "fish"]`.

This code demonstrates:
- Method definition's variable scope: variables in the outer code can only be accessed and modified if they are passed as arguments to the method and mutating operations are performed on those corresponding objects
- Ruby's pass by reference value behaviour: the method receives a reference to the original object; mutating operations will modify the original object, while non-mutating operations will create new objects within the method, which gives the appearance that Ruby is passing by value (i.e. when methods receive copies of values)
- Mutability of array objects, which means objects can be modified after they are created, and in particular the `[]=` setter method that replaces the value of the element in the array in place.

```
# Output

["CAT", "dog", "COW", "CHICKEN", "fish"]
```