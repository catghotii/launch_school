**Question 1: Variable Scope and Blocks (Basic)**

What will the following code output? Explain why.

```ruby
a = 7

def my_value(b)
  a = b
end

my_value(a + 5)
puts a
```

In the main scope, variable `a` is initialised with a reference to the integer `7`. The `my_value` method is called and passed an argument `(a + 5)`. The expression in the argument's parentheses is first evaluated (i.e. `7 + 5`), resulting in the integer `13`—this value is passed as an argument to the method.

Inside the method definition, the parameter `b` is bound to the integer `13`, and then the method body is evaluated: `a = b` is an assignment operation of one variable to another. In this assignment, the local variable `a` receives a copy of the reference stored in `b`, with the result that both variables point to the same integer object, `13`. This is also the return value of method as it is the last evaluated expression in the method.

`a = b` is actually an assignment operation, or an initialisation of the local variable `a`: even though this variable has the same name as the outer variable `a`, this is not a reassignment operation of that outer variable due to the self-contained scope of a method definition, where variables in the outer code cannot be directly accessed or modified unless they are passed as arguments during a method call and mutating operations are performed on those corresponding objects. If instead `a = b` appeared in a block, then reassignment would indeed occur as block's can access and modify variables in outer scopes.

(In this code, the outer variable `a` was not explicitly passed as an argument (instead the evaluated expression `a + 7` was passed), nor are there any mutating operations inside the method—and further, this code is dealing with immutable integer objects that cannot be modified after they're created!—so it would not be possible for the method to modify the value of the outer variable `a`!)

On the last line of the code snippet, `puts a` outputs `7`, which is the integer that the outer variable `a` references. In the outer scope, the only variable of the name `a` is only the variable that was initialised on line 1 in the outer scope. The inner variables `a` and `b` are locally scoped to the method definition, which means that they are only available within the method's scope, not in any surrounding outer scopes—the `puts` call in the main code cannot the variable called `a` in the method's scope.

**Question 2: String Mutation and Variables as Pointers (Intermediate)**

What will the following code output? Explain in detail.

```ruby
def change_string(str)
  str << ' world'
end

greeting = 'hello'
change_string(greeting)

puts greeting
```

In the main scope, the variable `greeting` is initialised with a reference to the string object `"hello"`, and then the `change_string` method is called and passed `greeting` as an argument—when the method is called and passed an argument, it receives a reference to the corresponding object.

Inside the method definition, the parameter `str` is bound to the same string object `"hello"` that `greeting` references. The destructive shovel operator `<<` modifies the original object in place by concatenating its argument to the string object, resulting in `"hello world"`. This mutation can be seen through any of its references, including the outer variable `greeting`.

The method's return value is the evaluated result of the last expression in the method body, the mutated string `"hello world"`, which is passed back to the calling code, although it is not used in this code. The last line in the entire code `puts greeting` outputs `"hello world"`.

This code demonstrates key concepts, including variable scope of a method definition, Ruby's pass by reference value behaviour, and mutations to original objects.

- Method definitions create a self-contained scope: variables initialised inside the method cannot be accessed by the outer code, and variables initialised in the outer code cannot be directly accessed or modified within the method unless they are passed as arguments during method invocation and mutating operations are performed on those corresponding objects.
- Ruby's pass by reference behaviour: the method receives a reference to the original object and what happens to the object depends on what types of operations occur inside the method.
- When mutating operations are performed on the original object inside a method, the object itself is modified in place, and the mutation can be examined through any of its references, including variables in the outer scope. If instead non-mutating operations were performed, new objects would be created and what the variable references would also change. In these cases, Ruby appears to pass by value (where copies of values are operated on, which have no effect on the original object or its references).

```
# Diagram

# Original state
greeting --> "hello"

# Beginning of method invocation
greeting --> "hello" <-- str

# After << (mutating method)
greeting --> "hello world" <-- str

# After method invocation
greeting --> "hello world"
```

**Question 3: Method Return Values and Truthiness (Intermediate)**

What will the following code output? Explain your answer with reference to how Ruby evaluates expressions.

```ruby
def check_value(value)
  if value
    "It's truthy!"
  else
    "It's falsy!"
  end
end

puts check_value(0)
puts check_value("")
puts check_value(nil)
```

The three `puts` calls will output the respective return values from the `check_value` method call, which is supplied with different arguments in each call.

In each call, the value supplied as an argument is passed as an argument, which is bound to the parameter `value`. Inside the method definition, the `if/else` statement is evaluated based on its truthiness. If the conditional expression `if value` is evaluated as truthy, the `if` branch is executed, returning the string `"It's truthy!"`, and if it's falsy, the `else` branch is executing, returning the string `"It's falsy!"`. Either of these strings are also the method's return value since they are the last evaluated expression the method body, and this return value is then passed back to the calling code.

The concept of truthiness is crucial to understanding how conditional flow is handled in `if` statements. In Ruby, every expression is truthy except for the two falsy values `false` and `nil`. This means that even empty objects, like empty strings or arrays or hashes, and even the integer `0` , is considered truthy—these 'empty' objects may be considered falsy in other programming languages!

The boolean objects `true` and `false`, whose only purpose is to convey either `true` or `false` is distinct from saying an expression is considered true (or is "truthy") or considered false (or is "falsy"). When a conditional statement is evaluated, Ruby doesn't check specifically for whether the expression evaluates to the boolean object `true` but rather whether it doesn't evaluate to either falsy values `false` or `nil`—in other words, it checks for whether evaluated result is not falsy (i.e. truthy).

In the first call, the integer `0` is passed as an argument. `0` is truthy, so the `if` condition evaluates as true, and the `if` branch is executed; the method returns `"It's truthy!"`, which is passed back to the calling code, `puts check_value(0)`, which outputs `"It's truthy!"`.

In the second call, the empty string `""` is passed as an argument; `""` is truthy; the `if` condition evaluates as true; the method returns `"It's truthy!"`, passing it immediately to `puts`, which outputs `"It's truthy!"`.

In the last call, the falsy object `nil` is passed as an argument; the `if` condition evaluates as false; the method returns `"It's falsy!"`, passing it immediately to `puts`, which outputs `"It's falsy!"`.

```
# Output
It's truthy!
It's truthy!
It's falsy!
```

**Question 4: Nested Blocks and Variable Scope (Advanced)**

What will the following code output? Explain the concept of variable scoping rules in detail.

```ruby
array = [1, 2, 3]

array.each do |num|
  a = 5
  array.map do |num|
    puts a
    a = 8
  end
end

puts a if defined?(a)
```

This code demonstrates variable scoping rules of blocks, and in particular, nested blocks. Variable scope of a block follows the rule that variables initialised in the outer scope can be accessed and modified from within a block, but not vice versa. For nested blocks, the same rule applies: nested blocks have access to its surrounding scopes, but variables initialised within the nested scope cannot be accessed by outer scopes.

In the main scope, the variable `array` is initialised with a reference to the array object `[1, 2, 3]`.

`each` is called on `array` and passed a block, creating a new block scope, and inside the block, the variable `a` is initialised with a reference to the integer object `5`. The `each` method iterates over the array object referenced by `array`, effectively iterating three times (corresponding to the number of elements in the array), executing the block code for each iteration, before returning the original collection.

The `map` method is called and passed a block, creating a nested scope, and inside the block, `puts a` outputs the value of `a`, and then the reassignment of the variable `a` occurs from within the nested scope. `map` also iterates over the same array object, executing its block code for three iterations, and then returns a new array of transformed elements based on the block's evaluated expressions.

It's important to note that from within the nested scope, the variable `a` which was initialised in the `each` block, can be reassigned. It's also important to note that upon each iteration of the `each` method, `a = 5` is evaluated again—that is, the assignment of `a` reverts back to referencing the integer `5` before the `map` method is executing within the `each` method's iterations.

The last line in the entire code snippet, `puts a if defined?(a)`, invokes the `defined?` keyword/operator, which checks whether its argument, `a`, is defined in the current scope. If the variable does not exist, `nil` is returned. The `if` statement uses truthiness to determine whether `puts a` should be executed: `nil` is falsy, so `puts a` is not executed.

```
# BREAKDOWN

# Variable assignments / reassignments in each scope

# Outer scope
array = [1, 2, 3]

# each block (inner scope)
a = 5

# map block (nested scope)
a = 8 --> a is reassigned to 8

# Iteration step-by-step

# each - 1st iteration
a = 5
  # map - 1st iteration
  puts a --> a => 5 --> outputs 5
  a = 8
  # map - 2nd iteration
  puts a --> a => 8 --> outputs 8
  a = 8
  # map - 3rd iteration
  puts a --> a => 8 --> outputs 8
  a = 8
# each - 2nd iteration
a = 5
  # map - 1st iteration
  puts a --> a => 5 --> outputs 5
  a = 8
  # map - 2nd iteration
  puts a --> a => 8 --> outputs 8
  a = 8
  # map - 3rd iteration
  puts a --> a => 8 --> outputs 8
  a = 8
# each - 2nd iteration
a = 5
  # map - 1st iteration
  puts a --> a => 5 --> outputs 5
  a = 8
  # map - 2nd iteration
  puts a --> a => 8 --> outputs 8
  a = 8
  # map - 3rd iteration
  puts a --> a => 8 --> outputs 8
  a = 8

# Final output

5
8
8
5
8
8
5
8
8
```

```ruby
# Comments added

array = [1, 2, 3]     # main scope / outer scope
                      # array is accessible to all scopes

array.each do |num|   # block scope
  a = 5               # a is accessible to each and map
  array.map do |num|  # nested scope / innermost scope
    puts a            # outputs 5
    a = 8             # a is reassigned from the nested scope
  end
end

puts a if defined?(a) # a does not exist in the main scope --> no output
```

**Question 5: Object Mutability and Method Return Values (Advanced)**

What will the following code output? Explain how pass-by-reference vs. pass-by-value concepts apply.

```ruby
def add_name(names, name)
  names << name
  name.upcase!
end

names = ['bob', 'kim']
name = 'jim'
add_name(names, name)

puts name
puts names
```

The variable `names` is initialised with a reference to the array object `['bob', 'kim']` and `name` is initialised with a reference to the string object `'jim'`. The `add_name` method is called and passed two arguments, `names` and `name`.

Inside the method definition, the parameters `names` and `name` receive references to the array and string objects referenced by the outer variables `names` and `name` (although they have the same names, they are distinct variables defined in different scopes).

The first expression in the method, `names << name`, is a mutating operation: the shovel operator `<<` pushes its argument to the array object (referenced by the local variable `names`), adding it as the last element in the array—this operation modifies the original array object in place, resulting in the array `['bob', 'kim', 'jim']`. This mutation can be seen through any of the original object's references, including the outer variable `names`.

The second operation in the method is another mutating operation: `upcase!` is called on the local variable `name`, mutating the string by changing lowercase letters to uppercase letters `'JIM'`. Once again, this mutation can be seen through any of its references, including the outer variable `name` but also the last element array object—this element is the original string object that was also passed as an argument to the method! This is because arrays contain individual objects with unique references and object ids, and if they are mutated elsewhere in the program, the array will also show these changes.

The method's return value is the same as the last evaluated expression in the method body, which is `'JIM'`, which is passed back to the calling code, although this is not used in this code.

`puts name` outputs `'JIM'`, while `puts names` outputs the values of array's elements in newlines:

```
# Output
JIM
bob
kim
JIM

# Diagram

# Original state
names (main scope) --> ['bob', 'kim']
name (main scope)  --> 'jim'

# Beginning of method invocation
names (main scope) --> ['bob', 'kim'] <-- names (method scope)
name (main scope)  --> 'jim'          <-- name (method scope)

# After << (mutating method)
names (main scope) --> ['bob', 'kim', 'jim'] <-- names (method scope)
name (main scope)  --> 'jim'                 <-- name (method scope)

# After upcase! (mutating method)
names (main scope) --> ['bob', 'kim', 'JIM'] <-- names (method scope)
name (main scope)  --> 'JIM'                 <-- name (method scope)

# After method invocation
names (main scope) --> ['bob', 'kim', 'JIM']
name (main scope)  --> 'JIM'
```

This code demonstrates key concepts:
- Variable scope of a method definition: methods create their own scope, where variables initialised in the outer scope cannot be directly accessed or modified unless they are passed as arguments and mutating operations are performed on those corresponding objects
- Ruby's pass by reference value behaviour: the method receives a reference to the original object and what happens to that object is determined by the types of operations performed in the method
- Mutating operations (vs non-mutating): mutating operations inside a method definition will mutate the original object in place rather than creating a new string. These mutations can be seen through any of the object's references.
- Mutability of objects, like arrays and strings: arrays are mutable objects whose elements are also unique objects with their own references. In this code, the array object has elements of string objects. String objects are also mutable unique objects, so if those string objects are mutated, the array will also see those changes!