
```
start 12:30
end   12:34
total 00:04
```

1.  ​**Basic**​: What will the following code output and why?

```ruby
a = 'hello'
b = a
a << ' world'

puts a
puts b
```

The variable `a` is initialised with a reference to the string object `"hello"`. In the assignment of one variable to another, `b` receives a copy of the reference stored in `a`, with the result that both variables contain references to the same string object `"hello"`.

`a << " world"` is then evaluated: `<<` is a mutating method that modifies the original object in place, concatenating it with its argument, `" world"`, resulting in the modified string `"hello world"`. Even though `<<` was performed on `a`, this mutation can be seen through any of its references, including `b`.

`puts a` and `puts b` output the same modified string, `"hello world"`.

```ruby
# Original state
a --> "hello" <-- b

# After << mutating method
a --> "hello world" <-- b

# Output:
hello world
hello world
```

```
start 12:35
end   12:44
total 00:09
```

2.  ​**Intermediate**​: Explain the difference between `each`, `map`, and `select` in Ruby. Provide code examples to illustrate your explanation.

`each`, `map` and `select` are all iterating methods that allow for repeatedly execution code over a collection of data, one element at a time. These methods are all non-destructive methods, which means that they do not modify the original calling collection but instead return new arrays. The core differences are how the return arrays are populated.

`each` iterates over a collection, executes the block code for each iteration, and then returns the original collection.

```ruby
# each
[1, 2, 3].each do |num|
  puts num
end

# Output:
1
2
3

# => returns original calling object [1, 2, 3]
```

`map` is used for transformation: while iterating over the collection and executing the block code, the new return array contains transformed elements. The return array is populated with the return values from the block, effectively transforming the elements in the original collection to the return values based on the block. The return array has the same number of elements as the original calling collection.

```ruby
# map
[1, 2, 3].map do |num|
  puts num # puts returns nil --> nil is the return value of the block
end

# line by line
# 1st iteration
num => 1
puts num => outputs 1 # returns `nil`
block return value => `nil`
map return array => [nil]

# 2nd iteration
num => 2
puts num => outputs 2 # returns `nil`
block return value => `nil`
map return array => [nil, nil]

# 3rd iteration
num => 3
puts num => outputs 3 # returns `nil`
block return value => `nil`
map return array => [nil, nil, nil]

# Output:
1
2
3

# => returns new array of transformed elements [nil, nil, nil]
```

`select`, unlike `map`, returns an array containing elements based on the truthiness of the return value by the block for each iteration. If the block return value evaluates as truthy, then the element for that iteration is added to the initially empty return array `[]`. If the block return value is falsy, nothing happens to the return array on that iteration.

```ruby
# select
[1, 2, 3].select do |num|
  num.even? # returns either boolean true or false
end

# line by line
# 1st iteration
num => 1
num.even? => `false`
block return value => `false`
truthiness of block return value evaluates as falsy
select return array => []

# 2nd iteration
num => 2
num.even? => `true`
block return value => `true`
truthiness of block return value evaluates as truthy
select return array => [2]

# 3rd iteration
num => 3
num.even? => `false`
block return value => `false`
truthiness of block return value evaluates as falsy
select return array => [2]

# => returns new array of selected elements [2]
```

```
start 12:47
end   13:00
total 00:13
```

3.  ​**Basic**​: What is variable scope in Ruby? Explain how variable scope works with methods and blocks.

Variable scope refers to where in a program a variable is available—"local" variable scope refers to how local variables have limited scope i.e. they are only available to limited parts of the program.

Method definitions create a self-contained scope: variables initialised inside methods cannot be accessed by outer code, and variables initialised in the outer scope cannot be directly accessed or modified unless they are passed in as arguments and mutating operations are performed on those corresponding objects.

```ruby
def capitalize_name(name) # parameter binds to argument passed to method
  name.capitalize! # mutating method modifies original object in place
end

person = "ruby"
p capitalize_name(person) # outer variable passed as argument to method 
# method returns `"Ruby"`
p person # mutation can be seen through the outer variable => `"Ruby"`

p name # error --> `name` inside method is a local variable, cannot be accessed by outer scope
```

For blocks, variables initialised in the outer code can be accessed and modified from within the code, however variables initialised inside the block cannot be accessed by the outer scope.

```ruby
name = "Ruby" # outer variable initialised

loop do
  person = "Cat" # block's local variable initialised
  name << "!" # can modify outer variable from within block
  puts name # outputs "Ruby!" since block has access to outer variables
end

puts name # outputs "Ruby!" - outer variable has been modified by block code
puts person # error - outer scope cannot access variables inside block
```

Other key points about the variable scope of blocks:

Variable shadowing occurs when a block's parameter has the same name as an outer variable. The parameter shadows outer variable with the same name, preventing access to the outer variable.

```ruby
num = 1

[1, 2, 3].each do |num| # block parameter has same name as outer variable
  puts num # outputs value assigned to num per iteration
end

puts num # outputs 1 from outer variable
```

Nested blocks / peer scopes: variables initialised in the outer scope can be accessed form within blocks, including nested blocks and peer blocks, plus a few specific rules:

- Nested blocks: the second-level scope cannot access variables initialised in the nested scope; while the third-level scope can access both second and first-level scopes.
- Peer scopes cannot access the other block's variables.

```ruby
# Nested blocks

# Main / outer scope
name = "ruby"

[1, 2, 3].each do |val| # Block / inner scope
  person = "cat" # variable initialised in inner scope of `each` block

  loop do # nested scope / innermost scope
    secret = "secret" # local variable only available to nested scope
    puts person # can access surrounding block's scope
    puts name # can access outer scope
    break
  end

  puts secret # error - cannot access nested scope
end

puts person # error - cannot access block scope
puts secret # error - cannot access nested scope
```

1333
1345
0012

4.  ​**Intermediate**​: What will the following code output and why?

```ruby
def fix(value)
  value = value.upcase!
  value.concat('!')
end

s = 'hello'
t = fix(s)

puts s
puts t
```

The variable `s` is initialised with a reference to the string object `"hello"`, and `t` is initialised with a reference to the return value of `fix(s)`. To evaluate the variable assignment, `fix(s)` is called and passed `s` as an argument. Inside the method definition, the `value` parameter is bound to the same string object `"hello"` that `s` references—effectively, the method receives a reference to this object.

The method body is then executed: `value = value.upcase!` is evaluated. The destructive method `upcase!` is called on `value`, which changes the string to uppercase characters, modifying the original object in place to the string `"HELLO"`. Even though the mutating method is called on `value` inside the method, this mutation can be seen through any of its references, including the outer variable `s`—`s` points to the modified object `"HELLO"`. `=` is an assignment operator: the local variable `value` receives a reference to the modified string `"HELLO"`. `value` contains a reference to this same string object.

`value.concat('!')` is another destructive method that modifies the calling object in place by concatenating the original object with its argument, resulting in `"HELLO!"`. Once again, this mutation affects any of its references, including the outer variable `s`.

The return value of the method is the same value as the last evaluated expression, `"HELLO!"`, which is passed back to the calling code; `t` receives a reference to this string object.

`puts s` and `puts t` will output the same value, as both variables contain references to the same string object after execution of the method is complete:

```ruby
# Diagram of variable references

# Original state
s = "hello"

# During method invocation
s --> "hello" <-- value
# After upcase!
s --> "HELLO!" <-- value
# After concat
s --> "HELLO!" <-- value

# After method invocation
s --> "HELLO!" <-- t

# Output:

HELLO!
HELLO!
```

This code demonstrates key concepts:
- Method definitions create their own scope: variables initialised in the other scope cannot be accessed or modified directly unless they are passed as arguments to the method and mutating operations are performed on those corresponding objects.
- Ruby's pass by reference value behaviour: the method receives a reference to the original object passed as an argument.
- Mutating operations inside methods: destructive methods modify the original object in place rather than creating new objects, which also affects any outer variables pointing to the original object—any mutations can be seen through outer references, like `s` (while non-mutating operations would disconnect the reference to the original object; any further operations inside the method would have no effect on the original object).

1350
1409
0019

5.  ​**Intermediate**​: Describe the difference between pass-by-value and pass-by-reference. Which does Ruby use? Provide an example to support your answer.

Pass-by-value refers to when during execution of a method invocation with an argument, the method receives a copy of the original object. This means that any operations performed within the method have no effect on the original object.

Pass-by-reference refers to when during execution of a method invocation with an argument, the method receives a reference to the original object. This means that operations performed within the method can affect the original object.

Ruby uses a pass-by-reference-value behaviour, which exhibits a combination of these object passing principles. In Ruby, during a method invocation with an argument, the method receives a reference to the original object. This means that what happens to the original object depends on whether the operations performed in the method are mutating or non-mutating.

If there are mutating operations, the original object is modified in place, and any mutations can be seen through any of its references outside the method.

If there are non-mutating operations, the original object is not affected—even though methods receive references to objects, they appear to receive copies of values because the original object is not affected (typically non-mutating operations will return new objects, breaking the connection with the original object's reference).

```ruby
# Ruby appears to pass by value when non-mutating operations are only performed during method invocations

my_name = "cat"

def pass_by_value(person)
  person = person.capitalize
end

name1 = pass_by_value(my_name)
p name1 # => "Cat"
p my_name # => "cat" # original object is not affected

# Ruby exhibits pass by reference behaviour when mutating operations are performed

def pass_by_reference(person)
  person.capitalize!
end

name2 = pass_by_reference(my_name) # original object state "cat" is passed as argument
p name2 # => "Cat"
p my_name # => "Cat" # original object has been permanently modified

# Ruby exhibits pass by reference value depending on the types of operations inside method definitions

# Pass by reference value with non mutating operation first

new_name = "ruby"

def pass_by_reference_value(person)
  person = person.downcase # non-mutating operation creates new object
  person.upcase! # mutating operation is performed on new object
end

name3 = pass_by_reference_value(new_name)
p name3 # => "RUBY"
p new_name # => "ruby" # original object not affected

# Pass by reference value with mutating operation first

def pass_by_reference_value2(person)
  person.upcase! # mutating operation modifies original object --> "CAT"
  person.downcase # non-mutating operation returns new object; does not modify original object from this point in execution onwards
end

name4 = pass_by_reference_value2(new_name)
p name4 # => "ruby"
p new_name # => "RUBY" # original object modified
```

1411
1423

6.  ​**Basic**​: What are the truthiness and falsiness rules in Ruby? Which values are considered falsey?

Every expression in Ruby is considered truthy except for the two falsy values `false` and `nil`. (Truthy values include empty arrays, hashes, strings, and the integer `0`—these objects may be considered falsy in other programming languages.)

Truthiness is used in conditional contexts. It refers to whether a value is considered to be true (i.e. "truthy") or considered to be false (i.e. "falsy")—in other words, whether an expression evaluates as true or evaluates as false. These terms "evaluates as" / "considered as" are distinct from the boolean objects `true` and `false` whose only purpose is to convey `true` or `false`. In conditional expressions, Ruby does not explicitly check for whether the expression evaluates to `true`, but rather whether the expression does not evaluate to either falsy values `false` or `nil`.

```ruby
# Truthiness

# Truthiness in conditional contexts: do not have to explicitly write `== true`

if 1 # always evaluates as truthy
  puts "you will see this" # so the if branch is always executed
else
  puts "you will never see this!"
end

# Truthiness in comparison operators

x = 10

if x > 5 # evaluates as truthy
  puts "it's true" # if branch is executed
else
  puts "not true"
end

x = 1

if x > 5 # evaluates as falsy
  puts "it's true"
else
  puts "not true" # else branch is executed
end

# Be careful not to use variable assignment in conditional expressions!

if x = 5 # assignments will always evaluate as truthy # might run an error/warning to use `==` instead
  puts "1 is greater than 0"
else
  puts "not greater than 0" # else branch is executed
end

## using `==` instead

if x == 5 # using `==` equality comparison instead
  puts "it's true"
else
  puts "not true" # else branch is executed
end
```

1425
1435

7.  ​**Advanced**​: What will the following code output and why?

```ruby
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

new_arr = arr.select do |n|
  n + 1
  puts n
end

p new_arr
```

The variable `arr` is initialised with a reference to the array object `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`, and `new_arr` is initialised with a reference to the return value of `select` called on `arr`.

The non-destructive `select` method iterates over a collection, executing the block code, and returns a new array containing the elements for which the block's return values are truthy. If the block's return value for that iteration evaluates as truthy, the element is selected and added to the new array (which is initially created as an empty array `[]`). If the block's return value evaluates as falsy, nothing happens to the return array on that iteration.

Inside the block, the parameter `n` is assigned the value of the current element, and the block code is executed: `n + 1` increments the value of `n` by `1` (although this evaluated result is not used in the code), and then `puts n` outputs the value of `n` and also returns `nil` (since `puts` returns `nil`)—this evaluated result is also the same as the return value if of the block since it is the evaluated result of the last expression in the block. `select` then checks for the truthiness of the return value from the block: `nil` evaluates as falsy, so nothing is added to the return array (whose initial state is `[]`). 

In this code, the return array remains unchanged throughout execution of the `select` method since all return values from the block are `nil` which evaluates as falsy, so the return array remains unchanged. At the end of execution of `select`, it returns the empty return array `[]` to the calling code—`new_arr` references this new return array.

`p new_arr` outputs `[]`.

```
# Code breakdown

# Beginning of `select` method
return array => []

# 1st iteration
n => 1
n + 1 => 2 # does not capture the evaluated result
puts n => outputs 1 # returns nil
block return value => nil
nil evaluates as falsy # nothing is added to the return array
return array => []

# this basic outline is the same for all iterations, except for the evaluated result of `n + 1` and the output from `puts n`

# At end of select method call
return array => []

# Variable assignment is evaluated
new_arr => []

# Output
1
2
3
4
5
6
7
8
9
10
[]
```

1436
1441

8.  ​**Intermediate**​: Explain what happens in the following code and why:

```ruby
a = "hi there"
b = a
a = "not here"

puts a
puts b
```

The variable `a` is initialised with a reference to the string object `"hi there"`. In the assignment of one variable to another `b` receives a copy of the reference stored in `a`, with the result that both variables contain references to the same string object `"hi there"`.

On line 3, `a` undergoes reassignment, which creates a new object and changes what the variable references. Effectively, `a` is disconnected from the reference to the original object, and `a` receives a different reference to the new string object `"not here"`. This reassignment has no effect on on the original object or any of its references. `b` continues to point to the original string `"hi there"`.

`puts a` and `puts b` outputs two different strings, demonstrating the disconnection of the original object when reassignment of `a` occurs.

```
# Diagram

# Original state
a --> "hi there" <-- b

# After reassignment of `a`
a --> "not here"
b --> "hi there"

# Output
not here
hi there
```

```
start 14:45
end   15:01
total 00:06
```

9.  ​**Advanced**​: What does the `Array#inject` method do? Provide an example of using `inject` to solve a problem.

The `inject` (or `reduce`) method allows for iterating over a collection of elements while also accumulating a value. The block parameters refer to the accumulator and current element of the iteration. If no argument is given, `inject` will use the first element as the accumulator and begin iteration from the second element. `inject` returns a final accumulated value when the operation is complete.

The `inject` method allows for iteration over a collection while also accumulating a value. The block parameters refer to the accumulator and the current element of the iteration. If no argument is given, the first element will be used as the accumulator value, and iteration begins from the second element. `inject` returns the final accumulated value.

```ruby
# `inject` without argument

result = [1, 2, 3].inject do |accumulator, element|
  accumulator + element
end

p result # => 6

# 1st iteration
# accumulator => 1
# element => 2
# accumulator + element --> 1 + 2 => 3

# # 2nd iteration
# accumulator => 3
# element => 3
# accumulator + element --> 3 + 3 => 6

# # After execution of inject method
# return accumulator value => 6

# using `each` method to accomplish same result

sum = 0 # sum is initialised outside of block to capture result
[1, 2, 3].each do |n|
  sum += n
end

p sum # => 6


# `inject` with argument

result = [1, 2, 3].inject(10) do |accumulator, element|
    accumulator + element
end

p result # => 16

# initial accumulator => 10

# 1st iteration
# accumulator => 10
# element => 1
# accumulator + element --> 10 + 1 => 11

# # 2nd iteration
# accumulator => 11
# element => 2
# accumulator + element --> 11 + 2 => 13

# # 2nd iteration
# accumulator => 13
# element => 3
# accumulator + element --> 13 + 3 => 16

# # After execution of inject method
# return accumulator value => 16
```

```ruby
names = ["cat", "ruby", "emerald"]

# Finding longest word

result = names.inject do |longest, word|
  longest.size > word.size ? longest : word
end

p result

# Creating a hash

names_hash = names.inject({}) do |hash, name|
  hash[name] = name.length
  hash
end

p names_hash
```

```
start 15:06
end   15:10
total 00:04
```

10. ​**Advanced**​: What will the following code output and why?

```ruby
def test  
  puts "written assessment"  
end  
  
var = test  
  
if var  
  puts "written assessment"  
else  
  puts "interview"  
end
```

The variable `var` is initialised with a reference to the return value of the `test` method invocation. `test` is called and executed, which outputs `"written assessment"`, and method's return value is `nil` because `puts` returns `nil`. This `nil` value is assigned to `var`.

The conditional `if` statement is evaluated: `if var` evaluates as falsy, because `nil` is a falsy value, so the `else` branch is executed, which outputs the string `"interview"`.

This code demonstrates the return value of a method, which is captured in a variable assignment, and then the variable is used in a conditional expression which is evaluated for its truthiness: the `if` branch is executed if the conditional expression evaluates as truthy, otherwise the `else` branch is executed.

```ruby
# Comments added

def test
  puts "written assessment" # puts returns nil
end

var = test # => nil

if var # evaluates to falsy
  puts "written assessment"
else
  puts "interview" # else branch is executed
end
```

```
# Output

written assessment
interview
```