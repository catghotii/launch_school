
1. **Basic**: What will the following code output and why? Be detailed in your explanation.

```ruby
a = "hello"
b = a
a = "goodbye"
puts b
```

The variable `a` is initialised with a reference to the string object `"hello"`.

In the assignment of one variable to another, `b = a`, the variable on the left `b` receives a copy of the reference stored in the variable on the right `a`. Both variables contain references to the same string object `"hello"`.

`a` undergoes reassignment: this reassignment changes what the variable `a` references—it creates a new string object `"goodbye"`, which is the object that `a` now references. This reassignment has no effect on other variables containing the original string object that `a` previously referenced—`b` still contains a reference to the original string object `"hello"`.

```ruby
# initially
a --> "hello" <-- b

# after reassignment:
a --> "goodbye"
b --> "hello" # b still points to the original object
```

`puts b` outputs the string that `b` is a reference to, which is the original string object `"hello"`.

The output is:

```
hello
```

2. **Intermediate**: Describe what happens in the following code. What will be the final values of `array1` and `array2`, and why?

```ruby
array1 = [1, 2, 3]
array2 = array1
array2.unshift(0)
array1.push(4)
p array1
p array2
```

The variable `array1` is initialised with a reference to the array object `[1, 2, 3]`. In the next variable assignment, `array2` receives a copy of the referenced stored in `array1`, with the result that both `array1` and `array2` contain references to the same array object `[1, 2, 3]`.

The destructive `unshift` method is called on `array2` and is passed an argument of `0`—the `unshift` method prepends its arguments to the object it's called on, resulting in the modified array `[0, 1, 2, 3]`. Both `array1` and `array2` are pointing to the same modified array at this stage in execution.

The destructive `push` method is called on `array1` with an argument of `4`—`push` appends the argument to the calling object, resulting in the modified array `[0, 1, 2, 3, 4]`. Again, both `array1` and `array2` are pointing to the same mutated array object.

It's important to note that mutating methods modify the existing object in place rather than creating new objects. Even though `unshift` and `push` were called on different variables in the code, the mutations to the original array object can be examined through any of the object's references.

```ruby
# original state
array1 --> [1, 2, 3] <-- array2

# after array2.unshift(0)
array1 --> [0, 1, 2, 3] <-- array2

# after array1.push(4)
array1 --> [0, 1, 2, 3, 4] <-- array2

p array1 # [0, 1, 2, 3, 4]
p array2 # [0, 1, 2, 3, 4]
```

`p array1` and `p array2` output the original array object that has been mutated by the `unshift` and `push` method calls.

Output is:

```
[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4]
```

3. **Intermediate** : What does the following code output and why? Focus on explaining the concept of variable scope in your answer.

```ruby
num = 10

def change_num(num)
  num = 20
end

change_num(num)
puts num
```

In the outer scope, the variable `num` is initialised with a reference to the integer `10`.

`change_num(num)` is evaluated, which calls the `change_num` method and passes `num` as an argument to the method.

Inside the method definition, the parameter `num` is bound to the same integer `10` that the outer variable `num` references.

Even though the parameter and outer variable share the same name, there is no variable shadowing occurring since method definitions create a self-contained scope—that is, local variables to the method definition cannot be accessed by outer code, and variables initialised in the outer scope cannot be directly accessed or modified unless they are passed as arguments. Effectively, the parameter of this method definition could be called anything else, and the same rules would apply: the variable `num` that's passed as an argument during the method call would be bound to the local variable initialised by the method's parameter when it is evaluated.

`num = 20` is then evaluated, which reassigns the local variable `num` to the value of `20`. This value is the return value of the method, as it is also the same value as the last evaluated expression in the method, which is then passed back to the calling code, although this value is not used.

This object passing behaviour by Ruby can be described as "pass by reference value" because the integer is being passed as an argument, and the reassignment does not affect the variable `num` outside the method definition. Moreover, integers in Ruby are immutable objects, which means that they cannot be modified in place—the reassignment operation will only create a new integer object, which has no effect on the outer variable `num` which references the original object.

`puts num` outputs `10` because the only variable called `num` that is available in the outer scope references the integer `10`, which has not been affected by the `change_num` method.


4. **Advanced** : Examine the following code and explain what it outputs and why. Pay special attention to how the `each` method interacts with local variables.

```ruby
arr = [1, 2, 3]
counter = 0

arr.each do |counter|
  counter += 1
end

puts counter
 ```

The variable `arr` is assigned with a reference to the array object `[1, 2, 3]`. The variable `counter` is assigned with a reference to the integer object `0`.

The `each` method is called on `arr` and passed a block, which iterates over each element and executes the block for each iteration, and returns the original calling object.

The variable scope of a block follows the rules that variables initialised within the block cannot be accessed by outer code, while variables initialised outside the block can be accessed and modified from within the block. In this code, the block parameter `counter` has the same name as the outer variable `counter`, therefore the block parameter shadows the outer variable of the same name, preventing access to the outer variable.

In each iteration, the block parameter `counter` is bound to the value of the current element, and then `counter += 1` increments the value of the current element by `1`.

Line by line:
- For the first iteration, `counter` is `1`, and the block code evaluates to `2`.
- For the second iteration, `counter` is `2`, and the block code evaluates to `3`.
- For the third iteration, `counter` is `3`, the block code evaluates to `4`.
- `each` returns the original array, which is `[1, 2, 3]`
- None of these values are used in the code.

In the original code, `puts counter` outputs the value of the outer variable called `counter` since the `each` method invocation with a block has no effect on the outer variable `counter`.

Output is:

```
0
```

If instead the block parameter was called a different name (e.g. `num`), but the code in the block remained the same (`counter += 1`), then the block would have access to outer variables which can then be reassigned from within the block.

```ruby
# refactored code demonstrating no variable shadowing and the result of reassignment from within the each block

arr = [1, 2, 3]
counter = 0

arr.each do |num| # block parameter name changed to num
  counter += 1    # outer variable counter is reassigned on each iteration
end

puts counter      # counter would now reference a new integer `3`
 ```