
1.  ​**Basic**​: What will the following code output and why?

```ruby
a = 'hello'
b = a
a = 'goodbye'
puts b
```

The variable `a` is initialised with a reference to the string object `"hello"`. In the assignment of one variable to another, `b` receives a copy of the reference stored in the variable `a`, with the result that both variables contain references to the same string object `"hello"`.

`a` is then reassigned to a new string object `"goodbye"`. This reassignment operation creates a new string object and changes what the variable `a` references, effectively disconnecting the reference to the original string object from `a`. `b` continues to point to the original string object `"hello"`, which is the output of `puts b` on the last line of the code.

```ruby
# Original state
a --> "hello"

# Variable assignment of b = c
a --> "hello" <-- b

# After reassignment of a
a --> "goodbye"
b --> "hello"

# puts b outputs:
hello
```


2.  ​**Intermediate**​: Explain what the following code does and what concept it demonstrates:

```ruby 
def fix(value)
  value.upcase!
  value.concat('!')
  value
end

s = 'hello'
t = fix(s)

puts s
puts t
```

The variable `s` is initialised with a reference to the string object `"hello"`. The variable `t` is initialised with a reference to the return value of `fix(s)`. `fix(s)` is a method call that's passed `s` as an argument. Inside the method definition, the parameter `value` is bound to the same string object that `s` references—effectively, the method receives a reference to the string object `"hello"`.

The method body is executed: `value.upcase!` calls the destructive `upcase!` method on `value`, which modifies the original object in place by changing it to uppercase characters, resulting in `"HELLO"`, and `value.concat('!')` also mutates the original object by concatenating the argument `'!'` to the string `"HELLO"`, resulting in `"HELLO!"`. Both of these methods are mutating operations that modify the original object in place rather than creating a new object, which means that these mutations can be seen through any of its references, including the outer variable `s`.

The method's return value is the evaluated result of `value`, returning the the mutated string `"HELLO!"`, which is passed back to the calling code—`t` is initialised with a reference to this same modified string. Effectively, both `s` and `t` point to the same string object, which can be verified by the `puts s` and `puts t` method calls at the end of the entire code, outputting the same string object.

This code demonstrates key concepts in Ruby:
- Variable scope of method definitions: method definitions create their own scope, whereby variables initialised within the method cannot be accessed by the outer scope, and variables initialised in the outer scope cannot be directly accessed or modified from within the method unless they are passed as arguments and mutating operations are performed on those corresponding objects.
- Ruby's pass by reference value behaviour: the `fix` method receives a reference to the same string object that `s` references.
- Mutating operations performed on the original object inside the method definition modify the original in place, and these mutations can be seen through any of its references, including variables outside the method definition, like `s`.
- The return value of a method is the same value as the last evaluated expression during execution of the method invocation, and this value can be used in further operations, like variable assignment.

```ruby
# Before `fix` method call
a --> "hello"

# During execution of the method call
a --> "hello" <-- value
a --> "HELLO" <-- value  # after upcase!
a --> "HELLO!" <-- value # after concat('!')

# After method call
a --> "HELLO!" <-- t

# Output:
HELLO!
HELLO!
```


3.  ​**Intermediate**​: What will the following code output and why?

```ruby
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

new_array = arr.select do |n|
  n + 1
  puts n
end

p new_array
```

The variable `arr` is initialised with a reference to the array object `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`.

The variable `new_arr` is initialised with a reference to the return value of `select` called on `arr`. The `select` method call must be evaluated before the variable assignment is evaluated.

The `select` method iterates over a collection and executes the block code for each iteration. It ultimately returns a new array containing the elements for which the block returns a truthy value. If the return value of the block evaluates as truthy, then the current element is selected and added to the return array, otherwise if the return value of the block is falsy, nothing happens to the return array for that iteration. At the beginning of execution, `select` creates an empty array `[]` that it populates with the selected elements.

In each iteration, the parameter `n` is assigned the value of the current element, and the operations inside the block are evaluated: `n + 1` increments the value of `n` by `1` (although this value is not actually used by the code), and `puts n` outputs the value of `n`. The return value of the block for each iteration is the last evaluated expression the block, `puts n`, which returns `nil` since `puts` returns `nil`. The block's return value is then checked for truthiness: `nil` evaluates as falsy, so none of the elements are added to the return array. After all iterations are completed, `select` returns the empty array `[]`, which is passed back to the calling code—`new_array` references the empty return array.

Each iteration of `select` looks like this:

```ruby
# First iteration as an example:
n => 1
1 + 1 => 2 # this evaluated result is not used
puts 1 =>  # outputs 1 # returns `nil`
# block's return value => `nil`
# `nil` is falsy --> nothing is added to the return array
# return array => []

# Second to last iterations:
# Same expressions are evaluated, ultimately each return value is evaluated as falsy
# return array => []

# After select method call
new_array => []

# Output of entire code:
1
2
3
4
5
6
7
8
9
10
[]
```

4.  ​**Advanced**​: Explain what happens in each step of the following code, and what concept it demonstrates:
  
```ruby
def increment(x)
  x << 'b'
end

y = 'a'
increment(y)
puts y

def increment_2(x)
  x = x + 'b'
end

z = 'a'
increment_2(z)
puts z
```

The variable `y` is initialised with a reference to the string object `"a"`. `increment(y)` is called and passed `y` as an argument. Inside the `increment` method definition, the parameter `x` is bound to the same string object `"a"` that `y` references—the method receives a reference to the string object that's passed as an argument. `<<` is a mutating operation that modifies the original object in place (rather than creating a new object) by concatenating its argument to the calling object, resulting in the mutated string `"ab"`. This string is also the return value of the method, as it is same value as the last evaluated expression during execution of the method, which is passed back to the calling code (although this value is not used by the calling code).

The mutations performed by the method can be seen through any of its references, including the outer variable `y`. `puts y` outputs `"ab"`, which is the mutated object after the method invocation.

Another variable called `z` is initialised with a reference to another string object `"a"`, and `increment_2(z)` is called and passed `z` as an argument. Inside the `increment_2` method, the parameter `x` receives a reference to the same string object that `z` references. Unlike the previous method that performed mutating operations, `increment_2` performs non-mutating operations on the object. `x + "b"` is a non-destructive operation, which creates a new string object, `"ab"`, which is assigned to the local variable `x` inside the method. This new string is also the return value of the method because it is also the evaluated result of the last expression in the method.

Notably, these non-mutating operations create a new object (rather than modifying the original object in place), which changes what the variable references—that is, the reference to the original object is disconnected from the local variable, so the non-destructive operation itself has no effect the original object it referenced previously. The outer variable `z` continues to point to the original object `"a"`, which can be seen when `puts z` is called.

This code demonstrates a few key concepts:

- Variable scope of a method definition: variables initialised in the outer code cannot be directly accessed or modified from within the method definition unless they are passed as arguments and mutating operations are performed on those corresponding objects.
- Ruby's pass by reference value behaviour: the method receives a reference to the original object passed as an argument, although what happens to the original object depends on whether the operations inside the method are destructive or non-destructive.
- Mutating vs non-mutating operations:
	- Mutating operations modify the original object in place and these changes can be seen through any of the object's references
	- Non-mutating operations create a new object and change what the local variable inside the method references --> the original object and its references remain unchanged